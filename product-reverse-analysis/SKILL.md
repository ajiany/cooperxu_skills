---
name: product-reverse-analysis
description: 当需要分析现有产品以提取需求、用户故事和业务场景时使用。适用于竞品分析、跨领域功能迁移、产品设计学习，或通过Playwright等自动化工具"复制"产品功能。
---

# 产品逆向分析

## 概述

系统化地分析现有产品，提取结构化的需求文档、用户故事和业务场景。这不是简单的"查看页面"，而是一种方法论，用于理解功能为什么存在（WHY）、如何工作（HOW）以及解决什么业务问题（WHAT）。

**核心原则**：深度产品分析需要自动化工具 + 结构化思维。仅靠手动浏览是不够的。

## 使用场景

```dot
digraph when_to_use {
    "需要分析现有产品？" [shape=diamond];
    "目标是提取需求/用户故事？" [shape=diamond];
    "使用此skill" [shape=box];
    "使用更简单的方法" [shape=box];

    "需要分析现有产品？" -> "目标是提取需求/用户故事？";
    "目标是提取需求/用户故事？" -> "使用此skill" [label="是"];
    "目标是提取需求/用户故事？" -> "使用更简单的方法" [label="否"];
}
```

**适用于**：
- 竞品分析
- 跨赛道功能迁移
- 产品设计学习
- 从现有产品反推PRD/用户故事

**不适用于**：
- 简单的截图描述
- 基础的页面导航帮助
- 非产品类URL（文档、文章）

## 分析框架

### 三层分析模型

```
第1层：表层（是什么 What）
├── UI组件与布局
├── 可见功能
└── 导航结构

第2层：交互层（怎么做 How）
├── 用户流程与工作流
├── 状态变化与反馈
└── 数据流与API调用

第3层：意图层（为什么 Why）
├── 解决的业务问题
├── 用户画像与场景
└── 设计决策与权衡
```

### 关键原则：不要跳过层级

大多数分析只停留在第1层。本skill要求深入分析。

**分析太浅的症状**：
- "这个页面有个登录按钮" ← 仅第1层
- 更好："用户必须通过身份验证才能访问个性化内容" ← 第2层
- 最佳："身份验证实现了数据持久化和跨设备同步，服务于[特定用户场景]" ← 第3层

## 快速参考：工具选择

| 分析目标 | 主要工具 | 为什么 |
|---------|---------|--------|
| 页面结构与UI | `browser_snapshot` | 可访问性树 > 截图 |
| 交互流程 | `browser_click`, `browser_type` | 测试实际行为 |
| 网络/API分析 | `browser_network_requests` | 理解数据流 |
| 技术栈检测 | `browser_evaluate` | 在页面上下文执行JS |
| 文本内容 | `mcp__web_reader__webReader` | 干净的markdown输出 |

**规则**：先用 `web_reader` 获取概览，再用 `browser_snapshot` 进行交互分析。

## 分步方法

### 阶段1：初始发现（5-10分钟）

**目标**：理解产品范围和结构

1. **快速内容扫描**
   ```bash
   # 使用web_reader快速提取内容
   mcp__web_reader__webReader(url)
   ```

2. **导航结构提取**
   ```bash
   # 获取可访问性快照
   browser_snapshot()
   # 提取导航链接和页面结构
   ```

3. **技术栈检测**
   ```javascript
   // 在页面上下文中执行browser_evaluate
   () => {
     return {
       frameworks: detectReactVueAngular(),
       uiLibs: detectUILibraries(),
       stateMgmt: detectStateManagement()
     }
   }
   ```

**输出**：产品概览、主要模块、技术栈

---

### 阶段2：深度交互分析（15-30分钟）

**目标**：绘制用户流程和状态变化

1. **核心用户旅程演练**
   ```
   browser_navigate(url)
   browser_snapshot()  // 初始状态
   browser_click(element)  // 执行操作
   browser_snapshot()  // 新状态
   // 对比：发生了什么变化？
   ```

2. **表单与输入分析**
   ```
   browser_fill_form(fields)
   // 观察验证规则、错误状态
   ```

3. **网络监控**
   ```
   browser_network_requests()
   // 调用了哪些API？
   // 发送/接收了什么数据？
   ```

**输出**：用户流程、状态图、API契约

---

### 阶段3：业务逻辑提取（10-20分钟）

**目标**：理解功能为什么存在

针对每个主要功能，回答：

1. **用户画像**：这是给谁用的？
   - 证据：基于角色的UI、权限差异、术语使用

2. **解决的问题**：什么痛点？
   - 证据：功能定位、文案、用户评价

3. **商业价值**：为什么企业提供这个功能？
   - 证据：变现方式、留存、获客

4. **设计权衡**：放弃了哪些替代方案？
   - 证据：限制、约束、变通方案

**输出**：用户故事、业务场景、设计理由

---

### 阶段4：文档合成（10-15分钟）

**目标**：生成结构化文档

#### PRD模板
```markdown
# 产品需求文档

## 产品概述
- **定位**：[解决什么问题？]
- **目标用户**：[给谁用？]
- **核心价值**：[为什么选择这个而非替代方案？]

## 功能模块

### 模块名称
- **描述**：[做什么]
- **优先级**：P0/P1/P2
- **用户价值**：[用户为什么在意]
- **技术复杂度**：低/中/高
- **依赖**：[需要什么]

## 非功能性需求
- 性能：[具体指标]
- 安全：[认证、数据保护]
- 可扩展性：[用户量处理能力]
```

#### 用户故事模板
```markdown
# 用户故事

## [用户角色]

### US-XXX：[功能名称]
**作为** [用户角色]
**我希望** [具体功能]
**以便** [业务价值]

**验收标准**：
- [ ] 给定 [上下文]，当 [操作]，则 [结果]
- [ ] [边界情况处理]

**优先级**：P0/P1/P2
**依赖**：US-XXX
**复杂度**：故事点
```

## 常见错误

| 错误 | 为什么错 | 如何修正 |
|------|---------|---------|
| **仅用截图分析** | 图片无法显示行为和意图 | 使用 `browser_snapshot` 获取可访问性树 |
| **功能罗列无"为什么"** | 错过设计意图和业务逻辑 | 始终问："这解决了什么问题？" |
| **跳过交互测试** | 无法理解流程和状态 | 点击按钮、填写表单、观察变化 |
| **忽略网络层** | 错过数据流和后端逻辑 | 使用 `browser_network_requests` |
| **单维度分析** | 单次测试会遗漏边界情况 | 同时测试正常路径和错误情况 |
| **不思考工具选择** | 错误工具 = 低效或错误结果 | 参考快速参考表 |

## 实际效果对比

**使用此skill之前**：
- 分析："AIBase有资讯、工具和模型板块"
- 深度：表层功能列表
- 可操作性：低

**使用此skill之后**：
- 分析："AIBase是一个AI生态聚合器。资讯驱动流量，工具驱动发现，模型驱动开发者采用——每个漏斗都通过企业服务实现变现"
- 深度：商业模式、用户旅程、技术架构
- 可操作性：高——可战略性复制或竞争

## 红旗警示——你做错了

- "我就截个图" ← 使用 `browser_snapshot`
- "这个功能是X" ← 补充"为Y用户，解决Z问题"
- "我不需要点击任何东西" ← 你怎么知道它有效？
- "网络请求不重要" ← 你错过了半壁江山
- "这只是个列表页" ← 列表解决了什么业务问题？

**所有这些意味着**：停下来。重读这个skill。再深入一点。
